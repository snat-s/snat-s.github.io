<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Algoritmario</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Algoritmario</h1>

<div id="outline-container-orge352f7d" class="outline-2">
<h2 id="orge352f7d">Gráficas</h2>
<div class="outline-text-2" id="text-orge352f7d">
</div>
<div id="outline-container-org6a8e797" class="outline-3">
<h3 id="org6a8e797">Representaciónes de Gráficas</h3>
<div class="outline-text-3" id="text-org6a8e797">
</div>
<div id="outline-container-org1e93cc4" class="outline-4">
<h4 id="org1e93cc4">Matrices de adyacencia</h4>
<div class="outline-text-4" id="text-org1e93cc4">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold;">adj</span>(N,vector(M, 0));
</pre>
</div>
</div>
</div>

<div id="outline-container-org229e538" class="outline-4">
<h4 id="org229e538">Matrices de</h4>
<div class="outline-text-4" id="text-org229e538">
<div class="org-src-container">
<pre class="src src-C++">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0e6f19e" class="outline-3">
<h3 id="org0e6f19e">BFS y DFS</h3>
<div class="outline-text-3" id="text-org0e6f19e">
</div>
<div id="outline-container-org7eea86b" class="outline-4">
<h4 id="org7eea86b">DFS</h4>
<div class="outline-text-4" id="text-org7eea86b">
<div class="org-src-container">
<pre class="src src-C++">
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f93d56" class="outline-4">
<h4 id="org7f93d56">BFS \(O(V+E)\)</h4>
<div class="outline-text-4" id="text-org7f93d56">
<p>
Puede usarse en una gráfica explícita con una lista de adyacencias:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">bfs</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; &amp;<span style="font-weight: bold; font-style: italic;">adj</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">start</span>, <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">bool</span>&gt; &amp;<span style="font-weight: bold; font-style: italic;">visited</span>) {
        <span style="font-weight: bold; text-decoration: underline;">queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">q</span>;
        q.push(start);
        visited[start] = <span style="font-weight: bold; text-decoration: underline;">true</span>;
        <span style="font-weight: bold;">while</span>(!q.empty()) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">node</span> = q.front();
                q.pop();
                <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">u</span> : adj[node]) {
                        <span style="font-weight: bold;">if</span>(!visited[u])
                                q.push(u);
                }
        }
        <span style="font-weight: bold;">return</span> ans;
}
</pre>
</div>
</div>


<ul class="org-ul">
<li><a id="org905651f"></a>Gráfica Implícita<br />
<div class="outline-text-5" id="text-org905651f">
<p>
Gráfica implícita (por ejemplo un laberínto)
</p>

<div class="org-src-container">
<pre class="src src-C++">
</pre>
</div>
</div>
</li>

<li><a id="org5bfec80"></a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgbe0d633" class="outline-3">
<h3 id="orgbe0d633">Disjointed Set Union (DSU)</h3>
<div class="outline-text-3" id="text-orgbe0d633">
</div>
<div id="outline-container-org264cef5" class="outline-4">
<h4 id="org264cef5">Union by Rank</h4>
<div class="outline-text-4" id="text-org264cef5">
<p>
Función en tiempo \(O(log(N))\) por operación.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">DSU</span> {
        <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">P</span>, <span style="font-weight: bold; font-style: italic;">H</span>;
        <span style="font-weight: bold;">DSU</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) : P(n), H(n, 0) {
                <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++)
                        P[i] = i;
        }
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">find</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>) {
                <span style="font-weight: bold;">if</span>(P[x] == x) {
                        <span style="font-weight: bold;">return</span> x;
                }
                <span style="font-weight: bold;">return</span> find(<span style="font-weight: bold; text-decoration: underline;">P</span>[x]);
        }
        <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">merge</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">y</span>) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">RootX</span> = find(x);
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">RootY</span> = finx(y);
                <span style="font-weight: bold;">if</span> (H[RootX] &gt; H[RootY]) {
                        swap(rootX, rootY);
                }
                P[RootX] = RootY;
                <span style="font-weight: bold;">if</span> (H[RootX] == H[RootY]) {
                        H[RootY]++;
                }
        }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf4afe19" class="outline-4">
<h4 id="orgf4afe19">Path Compression</h4>
<div class="outline-text-4" id="text-orgf4afe19">
<p>
Es bastante rápida y en la práctica si quieres implementar algo desde
cero puedes llegar a usarla. Corre en tiempo \(O(log(N))\) amortizado. Pero
cada operación puede llegar a ser \(O(N)\).
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">DSU</span> {
        <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">P</span>;
        <span style="font-weight: bold;">DSU</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) : P(n) {
                <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++) {
                        P[i] = i;
                }
        }
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">find</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>) {
                <span style="font-weight: bold;">if</span> (P[x] == x) {
                        <span style="font-weight: bold;">return</span> x;
                }
                <span style="font-weight: bold;">return</span> P[x] = find(<span style="font-weight: bold; text-decoration: underline;">P</span>[x]);
        }
        <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">merge</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">y</span>) {
                P[find(x)] = find(y);
        }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org182c0af" class="outline-4">
<h4 id="org182c0af">Union by Rank y Path Compression</h4>
<div class="outline-text-4" id="text-org182c0af">
<p>
Funciona en \(O(\alpha(N))\) amortizado y siendo realista es la única que vas a necesitar.
</p>

<p>
\(\alpha\): es la función inversa de Ackerman, es casi \(O(1)\).
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">DSU</span> {
        <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">P</span>, <span style="font-weight: bold; font-style: italic;">H</span>;
        <span style="font-weight: bold;">DSU</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) : P(n), H(n, 0) {
                <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; ++i) {
                        P[i] = i;
                }
        }
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">find</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>) {
                <span style="font-weight: bold;">if</span> (P[x] == x) {
                        <span style="font-weight: bold;">return</span> x;
                }
                <span style="font-weight: bold;">return</span> P[x] = find(<span style="font-weight: bold; text-decoration: underline;">P</span>[x]);
        }
        <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">merge</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">y</span>) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">rx</span> = find(x);
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">ry</span> = find(y);
                <span style="font-weight: bold;">if</span>(H[rx] &gt; H[ry])
                        swap(rx, ry);
                P[rx] = ry;
                <span style="font-weight: bold;">if</span> (H[rx] == H[ry]) {
                        H[ry]++;
                }
        }
        <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">same</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">b</span>) {
                <span style="font-weight: bold;">return</span> find(a) == find(b);
        }
        <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">print</span>() {
                <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">x</span> : P) {
                        cout &lt;&lt; x &lt;&lt; <span style="font-style: italic;">" "</span>;
                }
                <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-style: italic;">"\n"</span>;
        }
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd672c17" class="outline-3">
<h3 id="orgd672c17">MST</h3>
<div class="outline-text-3" id="text-orgd672c17">
</div>
<div id="outline-container-org0b82425" class="outline-4">
<h4 id="org0b82425">Kruskal</h4>
<div class="outline-text-4" id="text-org0b82425">
<p>
Vamos a utilizar un DSU con una ligera modificación,
ahora vamos a ponerle same.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">DSU</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">DSU de la parte anterior</span>
        <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">same</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">y</span>) {
                <span style="font-weight: bold;">return</span> find(x) == find(y);
        }
};
</pre>
</div>

<p>
El código de Kruskal en:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">priority_queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tuple</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>,<span style="font-weight: bold; text-decoration: underline;">int</span>,<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold; font-style: italic;">pq</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">w, a, b</span>
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; font-style: italic;">c</span>;
<span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; m; ++i) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        pq.push({-1*c,a,b});
 }
<span style="font-weight: bold; text-decoration: underline;">DSU</span> <span style="font-weight: bold;">dsu</span>(n+1);
<span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">ans</span> = 0;
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">size</span> = 0;
<span style="font-weight: bold;">while</span> (!pq.empty()) {
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">w</span>, <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>;
        tie(w,a,b) = pq.top();
        pq.pop();
        <span style="font-weight: bold;">if</span> (!dsu.same(a, b)) {
                size = max(dsu.merge(a, b), size);
                cout &lt;&lt; w*-1 &lt;&lt; <span style="font-style: italic;">"\n"</span>;
                ans += (w*-1);
        }
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-org7bd8153" class="outline-4">
<h4 id="org7bd8153">Prim</h4>
<div class="outline-text-4" id="text-org7bd8153">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold;">prim</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">start</span>, <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">bool</span>&gt; &amp;<span style="font-weight: bold; font-style: italic;">visited</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">pair</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt;&gt; &amp;<span style="font-weight: bold; font-style: italic;">adj</span>) {
        <span style="font-weight: bold; text-decoration: underline;">priority_queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tuple</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold; font-style: italic;">pq</span>;
        <span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold; font-style: italic;">ans</span> = 0, <span style="font-weight: bold; font-style: italic;">counter</span> = 1;
        visited[start] = <span style="font-weight: bold; text-decoration: underline;">true</span>;
        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">a</span> : adj[start]) {
                pq.push({-1*a.second, a.first});
        }

        <span style="font-weight: bold;">while</span> (!pq.empty()) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">w</span>, <span style="font-weight: bold; font-style: italic;">node</span>;
                tie(w, node) = pq.top();
                pq.pop();
                <span style="font-weight: bold;">if</span> (visited[node]) <span style="font-weight: bold;">continue</span>;
                ans+=w*-1;
                counter++;
                visited[node] = <span style="font-weight: bold; text-decoration: underline;">true</span>;
                <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">a</span> : adj[node]) {
                        pq.push({a.second*-1,a.first});
                }
        }
        <span style="font-weight: bold;">return</span>  ans;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1827f04" class="outline-3">
<h3 id="org1827f04">Single Source Shortest Path</h3>
<div class="outline-text-3" id="text-org1827f04">
</div>
<div id="outline-container-org1704e2c" class="outline-4">
<h4 id="org1704e2c">Dijikstra \(Nlog(N)\)</h4>
<div class="outline-text-4" id="text-org1704e2c">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">pair</span>&lt;ll,ll&gt;&gt;&gt; <span style="font-weight: bold;">adj</span>(n+1); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">b, w</span>
<span style="font-weight: bold; text-decoration: underline;">priority_queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tuple</span>&lt;ll, ll&gt;&gt; <span style="font-weight: bold; font-style: italic;">pq</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">w, a</span>
<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;ll&gt; <span style="font-weight: bold;">distance</span>(n+1, INF);

<span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; font-style: italic;">c</span>;
<span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; m; ++i) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        adj[a].push_back({b,c});
 }

pq.push({0,1});
distance[1] = 0;

<span style="font-weight: bold;">while</span> (!pq.empty()) {
        <span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold; font-style: italic;">w</span>, <span style="font-weight: bold; font-style: italic;">a</span>;
        tie(w, a) = pq.top();
        pq.pop();
        <span style="font-weight: bold;">if</span>(processed[a]) <span style="font-weight: bold;">continue</span>;
        processed[a] = <span style="font-weight: bold; text-decoration: underline;">true</span>; 
        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">u</span> : adj[a]) {
                <span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold; font-style: italic;">b</span> = u.first, <span style="font-weight: bold; font-style: italic;">w</span> = u.second;
                <span style="font-weight: bold;">if</span> (distance[a]+w &lt; distance[b]) {
                        distance[b] = distance[a]+w;
                        pq.push({-1*distance[b], b});
                }
        }
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-org6f368e7" class="outline-4">
<h4 id="org6f368e7">Bellman Ford \(O(V*E)\)</h4>
<div class="outline-text-4" id="text-org6f368e7">
<p>
Tienes un vector de distancias que inicia en infinito, y el lugar de
donde quieres iniciar lo pones en 0 <code>distancia[&lt;lugar de inicio&gt;] = 0</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 1; i &lt;= n; ++i) {
        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">e</span> : lista) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; font-style: italic;">w</span>;
                tie(a,b,w) = e;
                <span style="font-weight: bold;">if</span>(distancia[a] == INF) <span style="font-weight: bold;">continue</span>;
                distancia[b] = min(distancia[b], distancia[a]+w);
        }
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc81f0c5" class="outline-4">
<h4 id="orgc81f0c5">Floyd Warshall \(O(n^3)\) (APSP)</h4>
<div class="outline-text-4" id="text-orgc81f0c5">
<p>
Sirve para cuando te preguntan varias veces la misma pregunta
de encontrar el camino más corto.
</p>

<p>
Usas una matriz de adyacencias.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Inicializar matriz de adyacencias</span>
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++) {
        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">j</span> = 0; j &lt; n; j++) {
                <span style="font-weight: bold;">if</span>(i == j) mat[i][j] = 0;
                <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span>(mat[i][j]) distance[i][j] = mat[i][j];
                <span style="font-weight: bold;">else</span> mat[i][j] = INF;
        }
 }

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">procesar la matriz de adyacencias y cambiar los valores</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">de los caminos conocidos</span>

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Floyd Warshall</span>
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 1; i &lt;= n; i++) {
           <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">j</span> = 1; j &lt;= n; j++) {
                   <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">k</span> = 1; k &lt;=n; k++) {
                           distance[j][k] = min(distance[j][k], distance[j][i]+distance[i][k]);
                   }
           }
   }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4da6b28" class="outline-3">
<h3 id="org4da6b28">Topological Sort</h3>
<div class="outline-text-3" id="text-org4da6b28">
<p>
En este caso la gráfica va de 1 a n.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold;">adj</span>(n+1);
<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">bool</span>&gt; <span style="font-weight: bold; font-style: italic;">visited</span>(n+1, <span style="font-weight: bold; text-decoration: underline;">false</span>); <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">cuidado con este, vector bool puede ser traicionero</span>

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>;

<span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 1; i &lt;= m; ++i) {
        <span style="font-weight: bold; text-decoration: underline;">std</span>::cin &gt;&gt; a &gt;&gt; b;
        adj[a].push_back(b);
 }

<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">inDegree</span>(n+1, 0);
<span style="font-weight: bold; text-decoration: underline;">queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">q</span>;

<span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 1; i &lt;= n; ++i) {
        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">v</span> : adj[i]) {
                inDegree[v]++;
        }
 }

<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 1; i &lt;= n; i++) {
        <span style="font-weight: bold;">if</span> (inDegree[i] == 0) {
                q.push(i);
        }
 }

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">index</span> = 1;
<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">order</span>(n+1,0);

<span style="font-weight: bold;">while</span> (!q.empty()) {
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">v</span> = q.front();
        q.pop();
        order[index++] = v;

        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">u</span> : adj[v]) {
                inDegree[u]--;
                <span style="font-weight: bold;">if</span> (inDegree[u] == 0) {
                        q.push(u);
                }
        }

 }
<span style="font-weight: bold;">if</span> (index!=n) {
        <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-style: italic;">"Impossible\n"</span>;
 }
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span> : order) {
        <span style="font-weight: bold;">if</span>(a) cout &lt;&lt; a &lt;&lt; <span style="font-style: italic;">" "</span>;
 }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfc61963" class="outline-2">
<h2 id="orgfc61963">Árboles</h2>
<div class="outline-text-2" id="text-orgfc61963">
</div>
<div id="outline-container-orge7844f2" class="outline-4">
<h4 id="orge7844f2">Árboles Binarios</h4>
<div class="outline-text-4" id="text-orge7844f2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">node</span> {
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>;
        <span style="font-weight: bold; text-decoration: underline;">node</span> *<span style="font-weight: bold; font-style: italic;">right</span>, *<span style="font-weight: bold; font-style: italic;">left</span>;
        <span style="font-weight: bold;">node</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">v</span>) : val(v), right(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>), left(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>){}
        <span style="font-weight: bold;">node</span>() : val(0), right(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>), left(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>){}
};
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="orgf1f4b30"></a>Recorrer un árbol binario<br />
<div class="outline-text-5" id="text-orgf1f4b30">
<p>
Los códigos de inorden, orden y postorden tienen la misma idea de trasfondo.
La única diferencia es el momento en donde visitas el valor actual en el que
estás o lo dejas en el stack recursivo.
</p>

<p>
El recorrido por niveles es el único que cambia ya que en este caso tenemos
que hacer una exploración con una queue.
</p>
</div>

<ul class="org-ul">
<li><a id="org5c8f47c"></a>Inorden<br />
<div class="outline-text-6" id="text-org5c8f47c">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">inorden</span>(<span style="font-weight: bold; text-decoration: underline;">node</span> *<span style="font-weight: bold; font-style: italic;">root</span>) {
        <span style="font-weight: bold;">if</span>(root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) <span style="font-weight: bold;">return</span>;
        cout &lt;&lt; root-&gt;val &lt;&lt; <span style="font-style: italic;">" "</span>;
        inorden(root-&gt;left);
        inorden(root-&gt;right);
}
</pre>
</div>
</div>
</li>

<li><a id="org4a57d5e"></a>Orden<br />
<div class="outline-text-6" id="text-org4a57d5e">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">orden</span>(<span style="font-weight: bold; text-decoration: underline;">node</span> *<span style="font-weight: bold; font-style: italic;">root</span>) {
        <span style="font-weight: bold;">if</span>(root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) <span style="font-weight: bold;">return</span>;
        orden(root-&gt;left);
        cout &lt;&lt; root-&gt;val &lt;&lt; <span style="font-style: italic;">" "</span>;
        orden(root-&gt;right);
}
</pre>
</div>
</div>
</li>

<li><a id="orgda8c379"></a>Postorden<br />
<div class="outline-text-6" id="text-orgda8c379">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">postorden</span>(<span style="font-weight: bold; text-decoration: underline;">node</span> *<span style="font-weight: bold; font-style: italic;">root</span>) {
        <span style="font-weight: bold;">if</span>(root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) <span style="font-weight: bold;">return</span>;
        postorden(root-&gt;left);
        postorden(root-&gt;right);
        cout &lt;&lt; root-&gt;val &lt;&lt; <span style="font-style: italic;">" "</span>;
}
</pre>
</div>
</div>
</li>

<li><a id="org51fc5ef"></a>Orden por Nivel<br />
<div class="outline-text-6" id="text-org51fc5ef">
<p>
Una BFS.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tuple</span>&lt;<span style="font-weight: bold; text-decoration: underline;">TreeNode</span>*, <span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold; font-style: italic;">q</span>;
<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold; font-style: italic;">ans</span>;
q.push({root, 0});
<span style="font-weight: bold;">while</span>(!q.empty()) {
        <span style="font-weight: bold; text-decoration: underline;">TreeNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>;
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">CurrentDepth</span>;
        tie(node, CurrentDepth) = q.front();
        q.pop();
        <span style="font-weight: bold;">if</span>(node == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) <span style="font-weight: bold;">continue</span>;
        <span style="font-weight: bold;">if</span>(ans.size() &lt;= CurrentDepth)
                ans.resize(CurrentDepth+1);
        ans[CurrentDepth].push_back(node-&gt;val);
        q.push({node-&gt;left, CurrentDepth+1});
        q.push({node-&gt;right, CurrentDepth+1});
 }
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgeda48fe" class="outline-4">
<h4 id="orgeda48fe">Árboles Binarios de Búsqueda</h4>
<div class="outline-text-4" id="text-orgeda48fe">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Node</span> {
<span style="font-weight: bold;">public</span>:
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>;
        <span style="font-weight: bold; text-decoration: underline;">Node</span> *<span style="font-weight: bold; font-style: italic;">right</span>, *<span style="font-weight: bold; font-style: italic;">left</span>;

        <span style="font-weight: bold;">Node</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">v</span>) : val(v), right(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>), left(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>){}
        <span style="font-weight: bold;">Node</span>() : val(0), right(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>), left(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>){}
};

<span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold;">add</span>(<span style="font-weight: bold; text-decoration: underline;">Node</span> *<span style="font-weight: bold; font-style: italic;">root</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>) {
        <span style="font-weight: bold;">if</span>(root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) {
                <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Node</span>(val);
        }
        <span style="font-weight: bold;">if</span>(root-&gt;val&lt;val) {
                root-&gt;right = add(root-&gt;right, val);
        } <span style="font-weight: bold;">else</span> {
                root-&gt;left = add(root-&gt;left, val);
        }
        <span style="font-weight: bold;">return</span> root;
}
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">find</span>(<span style="font-weight: bold; text-decoration: underline;">Node</span> *<span style="font-weight: bold; font-style: italic;">root</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>) {
  <span style="font-weight: bold;">if</span> (root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) {
                <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  <span style="font-weight: bold;">if</span> (root-&gt;val == val) {
                <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }
        <span style="font-weight: bold;">if</span>(val &gt; root-&gt;val) {
                <span style="font-weight: bold;">return</span> find(root-&gt;right, val);
        }

        <span style="font-weight: bold;">return</span> find(root-&gt;left,val);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org172566b" class="outline-4">
<h4 id="org172566b">Árbol N-ario</h4>
<div class="outline-text-4" id="text-org172566b">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">node</span> {
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>;
        <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">node</span>*&gt; <span style="font-weight: bold; font-style: italic;">children</span>;
};
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.4)</p>
</div>
</body>
</html>
