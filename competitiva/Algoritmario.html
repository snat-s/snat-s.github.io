<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Algoritmario</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Algoritmario</h1>

<div id="outline-container-org06ad326" class="outline-2">
<h2 id="org06ad326">Gráficas</h2>
<div class="outline-text-2" id="text-org06ad326">
</div>
<div id="outline-container-org4f434a6" class="outline-3">
<h3 id="org4f434a6">Representaciónes de Gráficas</h3>
<div class="outline-text-3" id="text-org4f434a6">
</div>
<div id="outline-container-orgc9f6193" class="outline-4">
<h4 id="orgc9f6193">Matrices de adyacencia</h4>
</div>

<div id="outline-container-org4f4466f" class="outline-4">
<h4 id="org4f4466f">Matrices de</h4>
</div>
</div>

<div id="outline-container-orgb09fb24" class="outline-3">
<h3 id="orgb09fb24">BFS y DFS</h3>
<div class="outline-text-3" id="text-orgb09fb24">
</div>
<div id="outline-container-org298fefc" class="outline-4">
<h4 id="org298fefc">DFS</h4>
<div class="outline-text-4" id="text-org298fefc">
<div class="org-src-container">
<pre class="src src-C++">
</pre>
</div>
</div>
</div>

<div id="outline-container-org4443fcb" class="outline-4">
<h4 id="org4443fcb">BFS</h4>
<div class="outline-text-4" id="text-org4443fcb">
<div class="org-src-container">
<pre class="src src-C++">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcf2af11" class="outline-3">
<h3 id="orgcf2af11">Disjointed Set Union (DSU)</h3>
<div class="outline-text-3" id="text-orgcf2af11">
</div>
<div id="outline-container-org2f74d64" class="outline-4">
<h4 id="org2f74d64">Union by Rank</h4>
<div class="outline-text-4" id="text-org2f74d64">
<p>
Función en tiempo \(O(log(N))\) por operación.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">DSU</span> {
        <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">P</span>, <span style="font-weight: bold; font-style: italic;">H</span>;
        <span style="font-weight: bold;">DSU</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) : P(n), H(n, 0) {
                <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++)
                        P[i] = i;
        }
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">find</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>) {
                <span style="font-weight: bold;">if</span>(P[x] == x) {
                        <span style="font-weight: bold;">return</span> x;
                }
                <span style="font-weight: bold;">return</span> find(<span style="font-weight: bold; text-decoration: underline;">P</span>[x]);
        }
        <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">merge</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">y</span>) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">RootX</span> = find(x);
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">RootY</span> = finx(y);
                <span style="font-weight: bold;">if</span> (H[RootX] &gt; H[RootY]) {
                        swap(rootX, rootY);
                }
                P[RootX] = RootY;
                <span style="font-weight: bold;">if</span> (H[RootX] == H[RootY]) {
                        H[RootY]++;
                }
        }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org9b0b473" class="outline-4">
<h4 id="org9b0b473">Path Compression</h4>
<div class="outline-text-4" id="text-org9b0b473">
<p>
Es bastante rápida y en la práctica si quieres implementar algo desde
cero puedes llegar a usarla. Corre en tiempo \(O(log(N))\) amortizado.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">DSU</span> {
        <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">P</span>;
        <span style="font-weight: bold;">DSU</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) : P(n) {
                <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++) {
                        P[i] = i;
                }
        }
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">find</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>) {
                <span style="font-weight: bold;">if</span> (P[x] == x) {
                        <span style="font-weight: bold;">return</span> x;
                }
                <span style="font-weight: bold;">return</span> P[x] = find(<span style="font-weight: bold; text-decoration: underline;">P</span>[x]);
        }
        <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">merge</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">y</span>) {
                P[find(x)] = find(y);
        }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2337f94" class="outline-4">
<h4 id="org2337f94">Union by Rank y Path Compression</h4>
<div class="outline-text-4" id="text-org2337f94">
<p>
Funciona en \(O(\alpha(N))\) amortizado y siendo realista es la única que vas a necesitar.
</p>

<p>
\(\alpha\): es la función inversa de Ackerman, es casi \(O(1)\).
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">DSU</span> {
        <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">P</span>, <span style="font-weight: bold; font-style: italic;">H</span>;
        <span style="font-weight: bold;">DSU</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) : P(n), H(n, 0) {
                <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; ++i) {
                        P[i] = i;
                }
        }
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">find</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>) {
                <span style="font-weight: bold;">if</span> (P[x] == x) {
                        <span style="font-weight: bold;">return</span> x;
                }
                <span style="font-weight: bold;">return</span> P[x] = find(<span style="font-weight: bold; text-decoration: underline;">P</span>[x]);
        }
        <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">merge</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">y</span>) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">rx</span> = find(x);
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">ry</span> = find(y);
                <span style="font-weight: bold;">if</span>(H[rx] &gt; H[ry])
                        swap(rx, ry);
                P[rx] = ry;
                <span style="font-weight: bold;">if</span> (H[rx] == H[ry]) {
                        H[ry]++;
                }
        }
        <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">same</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">b</span>) {
                <span style="font-weight: bold;">return</span> find(a) == find(b);
        }
        <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">print</span>() {
                <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">x</span> : P) {
                        cout &lt;&lt; x &lt;&lt; <span style="font-style: italic;">" "</span>;
                }
                <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-style: italic;">"\n"</span>;
        }
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4f5df93" class="outline-3">
<h3 id="org4f5df93">MST</h3>
<div class="outline-text-3" id="text-org4f5df93">
</div>
<div id="outline-container-org02ea30a" class="outline-4">
<h4 id="org02ea30a">Kruskal</h4>
<div class="outline-text-4" id="text-org02ea30a">
<p>
Vamos a utilizar un DSU con una ligera modificación,
ahora vamos a ponerle same.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">DSU</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">DSU de la parte anterior</span>
        <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">same</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">y</span>) {
                <span style="font-weight: bold;">return</span> find(x) == find(y);
        }
};
</pre>
</div>

<p>
El código de Kruskal en:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">priority_queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tuple</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>,<span style="font-weight: bold; text-decoration: underline;">int</span>,<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold; font-style: italic;">pq</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">w, a, b</span>
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; font-style: italic;">c</span>;
<span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; m; ++i) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        pq.push({-1*c,a,b});
 }
<span style="font-weight: bold; text-decoration: underline;">DSU</span> <span style="font-weight: bold;">dsu</span>(n+1);
<span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">ans</span> = 0;
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">size</span> = 0;
<span style="font-weight: bold;">while</span> (!pq.empty()) {
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">w</span>, <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>;
        tie(w,a,b) = pq.top();
        pq.pop();
        <span style="font-weight: bold;">if</span> (!dsu.same(a, b)) {
                size = max(dsu.merge(a, b), size);
                cout &lt;&lt; w*-1 &lt;&lt; <span style="font-style: italic;">"\n"</span>;
                ans += (w*-1);
        }
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgba4f4fb" class="outline-4">
<h4 id="orgba4f4fb">Prim</h4>
<div class="outline-text-4" id="text-orgba4f4fb">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold;">prim</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">start</span>, <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">bool</span>&gt; &amp;<span style="font-weight: bold; font-style: italic;">visited</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">pair</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt;&gt; &amp;<span style="font-weight: bold; font-style: italic;">adj</span>) {
        <span style="font-weight: bold; text-decoration: underline;">priority_queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tuple</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold; font-style: italic;">pq</span>;
        <span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold; font-style: italic;">ans</span> = 0, <span style="font-weight: bold; font-style: italic;">counter</span> = 1;
        visited[start] = <span style="font-weight: bold; text-decoration: underline;">true</span>;
        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">a</span> : adj[start]) {
                pq.push({-1*a.second, a.first});
        }

        <span style="font-weight: bold;">while</span> (!pq.empty()) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">w</span>, <span style="font-weight: bold; font-style: italic;">node</span>;
                tie(w, node) = pq.top();
                pq.pop();
                <span style="font-weight: bold;">if</span> (visited[node]) <span style="font-weight: bold;">continue</span>;
                ans+=w*-1;
                counter++;
                visited[node] = <span style="font-weight: bold; text-decoration: underline;">true</span>;
                <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">a</span> : adj[node]) {
                        pq.push({a.second*-1,a.first});
                }
        }
        <span style="font-weight: bold;">return</span>  ans;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org991d79b" class="outline-3">
<h3 id="org991d79b">Single Source Shortest Path</h3>
<div class="outline-text-3" id="text-org991d79b">
</div>
<div id="outline-container-orgb636cd1" class="outline-4">
<h4 id="orgb636cd1">Dijikstra \(Nlog(N)\)</h4>
<div class="outline-text-4" id="text-orgb636cd1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">pair</span>&lt;ll,ll&gt;&gt;&gt; <span style="font-weight: bold;">adj</span>(n+1); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">b, w</span>
<span style="font-weight: bold; text-decoration: underline;">priority_queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tuple</span>&lt;ll, ll&gt;&gt; <span style="font-weight: bold; font-style: italic;">pq</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">w, a</span>
<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;ll&gt; <span style="font-weight: bold;">distance</span>(n+1, INF);

<span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; font-style: italic;">c</span>;
<span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; m; ++i) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        adj[a].push_back({b,c});
 }

pq.push({0,1});
distance[1] = 0;

<span style="font-weight: bold;">while</span> (!pq.empty()) {
        <span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold; font-style: italic;">w</span>, <span style="font-weight: bold; font-style: italic;">a</span>;
        tie(w, a) = pq.top();
        pq.pop();
        <span style="font-weight: bold;">if</span>(processed[a]) <span style="font-weight: bold;">continue</span>;
        processed[a] = <span style="font-weight: bold; text-decoration: underline;">true</span>; 
        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">u</span> : adj[a]) {
                <span style="font-weight: bold; text-decoration: underline;">ll</span> <span style="font-weight: bold; font-style: italic;">b</span> = u.first, <span style="font-weight: bold; font-style: italic;">w</span> = u.second;
                <span style="font-weight: bold;">if</span> (distance[a]+w &lt; distance[b]) {
                        distance[b] = distance[a]+w;
                        pq.push({-1*distance[b], b});
                }
        }
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdac84a2" class="outline-4">
<h4 id="orgdac84a2">Bellman Ford \(O(V*E)\)</h4>
<div class="outline-text-4" id="text-orgdac84a2">
<p>
Tienes un vector de distancias que inicia en infinito, y el lugar de
donde quieres iniciar lo pones en 0 <code>distancia[&lt;lugar de inicio&gt;] = 0</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 1; i &lt;= n; ++i) {
        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">e</span> : lista) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; font-style: italic;">w</span>;
                tie(a,b,w) = e;
                <span style="font-weight: bold;">if</span>(distancia[a] == INF) <span style="font-weight: bold;">continue</span>;
                distancia[b] = min(distancia[b], distancia[a]+w);
        }
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-org620476b" class="outline-4">
<h4 id="org620476b">Floyd Warshall \(O(n^3)\)</h4>
<div class="outline-text-4" id="text-org620476b">
<p>
Sirve para cuando te preguntan varias veces la misma pregunta
de encontrar el camino más corto.
</p>

<p>
Usas una matriz de adyacencias.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Inicializar matriz de adyacencias</span>
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++) {
        <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">j</span> = 0; j &lt; n; j++) {
                <span style="font-weight: bold;">if</span>(i == j) mat[i][j] = 0;
                <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span>(mat[i][j]) distance[i][j] = mat[i][j];
                <span style="font-weight: bold;">else</span> mat[i][j] = INF;
        }
 }

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">procesar la matriz de adyacencias y cambiar los valores</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">de los caminos conocidos</span>

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Floyd Warshall</span>
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 1; i &lt;= n; i++) {
           <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">j</span> = 1; j &lt;= n; j++) {
                   <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">k</span> = 1; k &lt;=n; k++) {
                           distance[j][k] = min(distance[j][k], distance[j][i]+distance[i][k]);
                   }
           }
   }
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org4f57d29" class="outline-2">
<h2 id="org4f57d29">Árboles</h2>
<div class="outline-text-2" id="text-org4f57d29">
</div>
<div id="outline-container-org39229c1" class="outline-4">
<h4 id="org39229c1">Árboles Binarios</h4>
<div class="outline-text-4" id="text-org39229c1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">node</span> {
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>;
        <span style="font-weight: bold; text-decoration: underline;">node</span> *<span style="font-weight: bold; font-style: italic;">right</span>, *<span style="font-weight: bold; font-style: italic;">left</span>;
        <span style="font-weight: bold;">node</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">v</span>) : val(v), right(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>), left(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>){}
        <span style="font-weight: bold;">node</span>() : val(0), right(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>), left(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>){}
};
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org4893419"></a>Recorrer un árbol binario<br />
<div class="outline-text-5" id="text-org4893419">
<p>
Los códigos de inorden, orden y postorden tienen la misma idea de trasfondo.
La única diferencia es el momento en donde visitas el valor actual en el que
estás o lo dejas en el stack recursivo.
</p>

<p>
El recorrido por niveles es el único que cambia ya que en este caso tenemos
que hacer una exploración con una queue.
</p>
</div>

<ul class="org-ul">
<li><a id="orgb406885"></a>Inorden<br />
<div class="outline-text-6" id="text-orgb406885">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">inorden</span>(<span style="font-weight: bold; text-decoration: underline;">node</span> *<span style="font-weight: bold; font-style: italic;">root</span>) {
        <span style="font-weight: bold;">if</span>(root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) <span style="font-weight: bold;">return</span>;
        cout &lt;&lt; root-&gt;val &lt;&lt; <span style="font-style: italic;">" "</span>;
        inorden(root-&gt;left);
        inorden(root-&gt;right);
}
</pre>
</div>
</div>
</li>

<li><a id="org120b197"></a>Orden<br />
<div class="outline-text-6" id="text-org120b197">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">orden</span>(<span style="font-weight: bold; text-decoration: underline;">node</span> *<span style="font-weight: bold; font-style: italic;">root</span>) {
        <span style="font-weight: bold;">if</span>(root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) <span style="font-weight: bold;">return</span>;
        orden(root-&gt;left);
        cout &lt;&lt; root-&gt;val &lt;&lt; <span style="font-style: italic;">" "</span>;
        orden(root-&gt;right);
}
</pre>
</div>
</div>
</li>

<li><a id="org8e47479"></a>Postorden<br />
<div class="outline-text-6" id="text-org8e47479">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">postorden</span>(<span style="font-weight: bold; text-decoration: underline;">node</span> *<span style="font-weight: bold; font-style: italic;">root</span>) {
        <span style="font-weight: bold;">if</span>(root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) <span style="font-weight: bold;">return</span>;
        postorden(root-&gt;left);
        postorden(root-&gt;right);
        cout &lt;&lt; root-&gt;val &lt;&lt; <span style="font-style: italic;">" "</span>;
}
</pre>
</div>
</div>
</li>

<li><a id="orge6e35f5"></a>Orden por Nivel<br />
<div class="outline-text-6" id="text-orge6e35f5">
<p>
Una BFS.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">queue</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tuple</span>&lt;<span style="font-weight: bold; text-decoration: underline;">TreeNode</span>*, <span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold; font-style: italic;">q</span>;
<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&gt; <span style="font-weight: bold; font-style: italic;">ans</span>;
q.push({root, 0});
<span style="font-weight: bold;">while</span>(!q.empty()) {
        <span style="font-weight: bold; text-decoration: underline;">TreeNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>;
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">CurrentDepth</span>;
        tie(node, CurrentDepth) = q.front();
        q.pop();
        <span style="font-weight: bold;">if</span>(node == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) <span style="font-weight: bold;">continue</span>;
        <span style="font-weight: bold;">if</span>(ans.size() &lt;= CurrentDepth)
                ans.resize(CurrentDepth+1);
        ans[CurrentDepth].push_back(node-&gt;val);
        q.push({node-&gt;left, CurrentDepth+1});
        q.push({node-&gt;right, CurrentDepth+1});
 }
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgdb0bd4d" class="outline-4">
<h4 id="orgdb0bd4d">Árboles Binarios de Búsqueda</h4>
<div class="outline-text-4" id="text-orgdb0bd4d">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Node</span> {
<span style="font-weight: bold;">public</span>:
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>;
        <span style="font-weight: bold; text-decoration: underline;">Node</span> *<span style="font-weight: bold; font-style: italic;">right</span>, *<span style="font-weight: bold; font-style: italic;">left</span>;

        <span style="font-weight: bold;">Node</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">v</span>) : val(v), right(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>), left(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>){}
        <span style="font-weight: bold;">Node</span>() : val(0), right(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>), left(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>){}
};

<span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold;">add</span>(<span style="font-weight: bold; text-decoration: underline;">Node</span> *<span style="font-weight: bold; font-style: italic;">root</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>) {
        <span style="font-weight: bold;">if</span>(root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) {
                <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Node</span>(val);
        }
        <span style="font-weight: bold;">if</span>(root-&gt;val&lt;val) {
                root-&gt;right = add(root-&gt;right, val);
        } <span style="font-weight: bold;">else</span> {
                root-&gt;left = add(root-&gt;left, val);
        }
        <span style="font-weight: bold;">return</span> root;
}
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">find</span>(<span style="font-weight: bold; text-decoration: underline;">Node</span> *<span style="font-weight: bold; font-style: italic;">root</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>) {
  <span style="font-weight: bold;">if</span> (root == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>) {
                <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  <span style="font-weight: bold;">if</span> (root-&gt;val == val) {
                <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }
        <span style="font-weight: bold;">if</span>(val &gt; root-&gt;val) {
                <span style="font-weight: bold;">return</span> find(root-&gt;right, val);
        }

        <span style="font-weight: bold;">return</span> find(root-&gt;left,val);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org416f1bd" class="outline-4">
<h4 id="org416f1bd">Árbol N-ario</h4>
<div class="outline-text-4" id="text-org416f1bd">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">node</span> {
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">val</span>;
        <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">node</span>*&gt; <span style="font-weight: bold; font-style: italic;">children</span>;
};
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.4)</p>
</div>
</body>
</html>
